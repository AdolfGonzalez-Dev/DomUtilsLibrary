{"version":3,"sources":["../src/reactive/signals.js"],"names":[],"mappings":"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","file":"reactive.js","sourcesContent":["// src/reactive/signals.js\n// Improved reactive primitives with dependency tracking, cleanup and disposers.\n// - createSignal: [get, set, subscribe]\n// - createEffect(fn): returns disposer()\n// - createComputed(fn): returns getter that caches and invalidates automatically\n// - $state: proxy that participates in dependency tracking per-property\n\nconst EFFECT_STACK = []; // stack of active effect runners\nconst EFFECT_DEPS = new WeakMap(); // Map<runner, Set<signalKey>>\n\n/**\n * Internal helper: track that `runner` depends on `signalKey`.\n * signalKey is any object with a __subs Set (e.g. a getter function or a property signal object).\n */\nfunction _trackDependency(runner, signalKey) {\n  if (!runner || !signalKey) return;\n  if (!signalKey.__subs) signalKey.__subs = new Set();\n  if (!signalKey.__subs.has(runner)) {\n    signalKey.__subs.add(runner);\n  }\n\n  let deps = EFFECT_DEPS.get(runner);\n  if (!deps) {\n    deps = new Set();\n    EFFECT_DEPS.set(runner, deps);\n  }\n  deps.add(signalKey);\n}\n\n/**\n * createSignal(initial)\n * returns [get, set, subscribe]\n */\nexport function createSignal(initial) {\n  let value = initial;\n  const subs = new Set(); // user subscribers and effect runners will be stored here\n\n  function get() {\n    const active = EFFECT_STACK[EFFECT_STACK.length - 1];\n    if (active) {\n      _trackDependency(active, get);\n    }\n    return value;\n  }\n\n  // attach __subs so tracking code can use it\n  get.__subs = subs;\n\n  function set(newVal) {\n    const old = value;\n    if (typeof newVal === 'function') {\n      value = newVal(value);\n    } else {\n      value = newVal;\n    }\n    if (old === value) return value;\n\n    // notify subscribers (copy to avoid mutation during iteration)\n    const arr = Array.from(subs);\n    arr.forEach((fn) => {\n      try { fn(); } catch (err) { setTimeout(() => { throw err; }); }\n    });\n    return value;\n  }\n\n  function subscribe(fn) {\n    if (typeof fn !== 'function') return () => {};\n    subs.add(fn);\n    return () => subs.delete(fn);\n  }\n\n  return [get, set, subscribe];\n}\n\n/**\n * createEffect(fn)\n * - runs fn immediately and whenever its dependencies change\n * - supports cleanup: if fn returns a function, it will be called before next run and on dispose\n * - returns a disposer function to stop the effect and clean up subscriptions\n */\nexport function createEffect(fn) {\n  if (typeof fn !== 'function') throw new Error('createEffect: fn must be a function');\n\n  let cleanup = null;\n\n  const runner = () => {\n    // remove previous subscriptions for this runner\n    const prevDeps = EFFECT_DEPS.get(runner);\n    if (prevDeps) {\n      prevDeps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(runner); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(runner);\n    }\n\n    // execute previous cleanup\n    try { if (typeof cleanup === 'function') cleanup(); } catch (err) { console.error(err); }\n    cleanup = null;\n\n    // run effect and collect dependencies\n    EFFECT_STACK.push(runner);\n    try {\n      const maybeCleanup = fn();\n      if (typeof maybeCleanup === 'function') cleanup = maybeCleanup;\n    } catch (err) {\n      console.error('createEffect error', err);\n    } finally {\n      EFFECT_STACK.pop();\n    }\n  };\n\n  // initial run\n  runner();\n\n  // return disposer\n  return () => {\n    const deps = EFFECT_DEPS.get(runner);\n    if (deps) {\n      deps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(runner); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(runner);\n    }\n    try { if (typeof cleanup === 'function') cleanup(); } catch (err) { console.error(err); }\n    cleanup = null;\n  };\n}\n\n/**\n * createComputed(fn)\n * - returns a getter function that caches the computed value\n * - when dependencies change it marks dirty; the next call recomputes\n */\nexport function createComputed(fn) {\n  if (typeof fn !== 'function') throw new Error('createComputed: fn must be a function');\n\n  let cached;\n  let dirty = true;\n  let cleanup = null;\n\n  const recompute = () => {\n    // remove prev deps\n    const prevDeps = EFFECT_DEPS.get(recompute);\n    if (prevDeps) {\n      prevDeps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(recompute); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(recompute);\n    }\n    try { if (typeof cleanup === 'function') cleanup(); } catch (_) {}\n    cleanup = null;\n\n    EFFECT_STACK.push(recompute);\n    try {\n      const result = fn();\n      if (typeof result === 'function') {\n        // compute returned a cleanup function\n        cleanup = result;\n      } else {\n        cached = result;\n      }\n      dirty = false;\n    } catch (err) {\n      console.error('createComputed error', err);\n    } finally {\n      EFFECT_STACK.pop();\n    }\n  };\n\n  // initial compute\n  recompute();\n\n  // getter\n  return () => {\n    if (dirty) recompute();\n    return cached;\n  };\n}\n\n/**\n * $state implementation that participates in dependency tracking per property.\n *\n * Implementation details:\n * - For each proxied target object we keep a Map of property -> signalKey object.\n * - signalKey is a plain object with a __subs Set that stores effect runners (functions).\n * - When a property is read inside an active effect, we call _trackDependency(activeRunner, signalKey).\n * - When a property is set or deleted, we notify signalKey.__subs by calling each runner.\n * - Additionally, the returned proxy exposes a .subscribe(fn) that behaves like before:\n *   fn(key, oldVal, newVal) will be called for any property change.\n */\n\nconst STATE_PROP_SIGNALS = new WeakMap(); // Map<target, Map<prop, signalKey>>\n\nfunction _ensurePropSignalFor(target, prop) {\n  let map = STATE_PROP_SIGNALS.get(target);\n  if (!map) {\n    map = new Map();\n    STATE_PROP_SIGNALS.set(target, map);\n  }\n  let sig = map.get(prop);\n  if (!sig) {\n    sig = { __subs: new Set() }; // subscribers (effect runners)\n    map.set(prop, sig);\n  }\n  return sig;\n}\n\nexport function $state(initial = {}) {\n  const globalSubs = new Set();\n\n  const notifyGlobal = (key, oldVal, newVal) => {\n    globalSubs.forEach(fn => {\n      try { fn(key, oldVal, newVal); } catch (err) { console.error(err); }\n    });\n  };\n\n  const handler = {\n    get(target, prop, receiver) {\n      if (prop === '__isState') return true;\n      if (prop === 'subscribe') return (fn) => { globalSubs.add(fn); return () => globalSubs.delete(fn); };\n      if (prop === 'inspect') return () => Object.assign({}, target);\n\n      // tracking: if inside an effect, register dependency on this property\n      const active = EFFECT_STACK[EFFECT_STACK.length - 1];\n      if (active && typeof prop === 'string') {\n        const sig = _ensurePropSignalFor(target, prop);\n        _trackDependency(active, sig);\n      }\n\n      // normal property access\n      return Reflect.get(target, prop, receiver);\n    },\n\n    set(target, prop, value, receiver) {\n      const old = target[prop];\n      if (old === value) { target[prop] = value; return true; }\n      const result = Reflect.set(target, prop, value, receiver);\n\n      // notify property-specific subscribers (effect runners)\n      const map = STATE_PROP_SIGNALS.get(target);\n      if (map) {\n        const sig = map.get(prop);\n        if (sig && sig.__subs) {\n          Array.from(sig.__subs).forEach((runner) => {\n            try { runner(); } catch (err) { setTimeout(() => { throw err; }); }\n          });\n        }\n      }\n\n      // notify global subscribers\n      notifyGlobal(prop, old, value);\n      return result;\n    },\n\n    deleteProperty(target, prop) {\n      const old = target[prop];\n      const existed = prop in target;\n      const result = Reflect.deleteProperty(target, prop);\n\n      if (existed) {\n        // notify property-specific subscribers\n        const map = STATE_PROP_SIGNALS.get(target);\n        if (map) {\n          const sig = map.get(prop);\n          if (sig && sig.__subs) {\n            Array.from(sig.__subs).forEach((runner) => {\n              try { runner(); } catch (err) { setTimeout(() => { throw err; }); }\n            });\n          }\n          map.delete(prop);\n        }\n\n        // global subscribers\n        notifyGlobal(prop, old, undefined);\n      }\n      return result;\n    }\n  };\n\n  return new Proxy(Object.assign({}, initial), handler);\n}\n\nexport default {\n  createSignal,\n  createEffect,\n  createComputed,\n  $state\n};\n"]}